\documentclass[10pt,a4paper,french]{article}
\author{par Léo Peyronnet}
\title{Interpolation et Approximation}
\date{Novembre 2022}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{babel}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{tabto}
\usepackage{color}

\lstset{
  aboveskip=3mm,
  belowskip=-2mm,
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{red},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  framexleftmargin=16pt,
  framextopmargin=3pt,
  framexbottommargin=6pt,
  frame=tb,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=C,
  literate=
  {²}{{\textsuperscript{2}}}1
  {⁴}{{\textsuperscript{4}}}1
  {⁶}{{\textsuperscript{6}}}1
  {⁸}{{\textsuperscript{8}}}1
  {€}{{\euro{}}}1
  {é}{{\'e}}1
  {è}{{\`{e}}}1
  {ê}{{\^{e}}}1
  {ë}{{\¨{e}}}1
  {É}{{\'{E}}}1
  {Ê}{{\^{E}}}1
  {û}{{\^{u}}}1
  {ù}{{\`{u}}}1
  {â}{{\^{a}}}1
  {à}{{\`{a}}}1
  {á}{{\'{a}}}1
  {ã}{{\~{a}}}1
  {Á}{{\'{A}}}1
  {Â}{{\^{A}}}1
  {Ã}{{\~{A}}}1
  {ç}{{\c{c}}}1
  {Ç}{{\c{C}}}1
  {õ}{{\~{o}}}1
  {ó}{{\'{o}}}1
  {ô}{{\^{o}}}1
  {Õ}{{\~{O}}}1
  {Ó}{{\'{O}}}1
  {Ô}{{\^{O}}}1
  {î}{{\^{i}}}1
  {Î}{{\^{I}}}1
  {í}{{\'{i}}}1
  {Í}{{\~{Í}}}1,
  morekeywords={*,...},
  numbers=left,
  numbersep=10pt,
  numberstyle=\tiny\color{black},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  stringstyle=\color{gray},
  tabsize=4,
  title=\lstname,
}

\begin{document}
\maketitle
Compte rendu du TP consistant à programmer et comparer certaines méthodes d'interpolation et d'approximation.
\section{Rappel des méthodes}
\subsection{Méthodes d'interpolations}
L'interpolation est une opération mathématique visant à déterminer une fonction passant par des points donnés du plan. Plus précisément, soient $x_1,...,x_n$ des réels distincts, $y_1,...,y_n$ des réels, $n \in \mathbb{N^*}$. Alors l'interpolation consiste à déterminer une fonction telle que $\forall i \in [1,n],f(x_i)=y_i$; ce qui correspond à passer par l'ensemble des points d'interpolations $(x_i,y_i)$.

Les méthodes détaillés ci-dessous interpolent des fonctions polynomiales de degré au plus $n-1$.
\subsubsection{Méthode de Lagrange}
La méthode de Lagrange se base sur le principe de superposition, c'est à dire que les points d'interpolation vont être traités un par un.

Soit $L_1,...,L_n \in \mathbb{R}_{(n-1)}[X]$ tels que $\forall a,b \in [1,n]$, $L_a(x_b)=1$ si $a=b$, $0$ sinon, alors le polynôme $P_{(n-1)}$ est exprimé sous la forme:
\begin{align*}
P_{(n-1)}(x)=\sum_{i=0}^{(n-1)}y_i L_i(x)
\end{align*}
avec $L_i(x)$:
\begin{align*}
L_i(x)=\prod_{j=0,j\neq i}^{(n-1)}\frac{x-x_j}{x_i-x_j}
\end{align*}
\subsubsection{Méthode de Neville}
Quant à elle, la méthode de Neville se base sur la décomposition du polynome $P_{(n-1)}[x_1,x_2,...,x_n]$ en $P_{(n-2)}[x_1,x_2,...,x_{n-1}]$ et $P_{(n-2)}[x_2,x_3,...,x_{n}]$.

Alors, en admettant $P_0[x_i],\forall x,i=1,...,n ; P_0[x_i](x)=y_i$:
{\tiny
\begin{align*}
&\forall x,P_{k}[x_i,...,x_{i+k}](x)=\frac{(x-x_{i+k})P_{k-1}[x_i,...,x_{i+k-1}](x)+(x_i-x)P_{k-1}[x_i+1,...,x_{i+k}](x)}{x_i-x_{i+k}},\\&\forall k=1,...,n-1
\end{align*}
}
\section{Présentation des programmes}
\subsection{lagrange()}
\begin{lstlisting}
float lagrange(float * X,float * Y,float xentree, int taille){
    float result=0;
    for (int i=0;i<taille;i++){ 
        float Li=1;
        for (int j=0;j<taille;j++){
            if (j!=i){
                Li*=(xentree-X[j])/(X[i]-X[j]);
            }
        }  
        result+=Y[i]*Li;
    }
    return result;
}
\end{lstlisting}
La boucle $j$ correspond à l'opérateur produit, la boucle $i$ correspond à l'opérateur somme.
\subsection{neville()}
\begin{lstlisting}
double neville(float * X,float * Y,float xentree, int n){
    double * Pk=(double *)malloc(n * sizeof(double));
    if (Pk==NULL){return 0;}
    for (int j=0;j<n;j++){
        Pk[j]=Y[j];
    }

    for(int k=1;k<n;k++){
        for(int i=0;i<n;i++){
            Pk[i]=((xentree-X[i+k])*Pk[i]+(X[i]-xentree)*Pk[i+1])/(X[i]-X[i+k]);
        }
    }
    return Pk[0];
}

\end{lstlisting}
\section{Observations sur les jeux d'essais}
\section{Conclusion}
\end{document}